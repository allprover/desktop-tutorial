# 一、static

## 1. static 作用

在C/C++中，关键字static有两种用法：

• 修饰变量：使变量在程序运行期间仅被初始化一次，并且作用域只在定义该变量的源文件内部，即静态局部变量和静态全局变量。

• 修饰函数：将函数的作用域限制在定义该函数的源文件内部，即静态函数。

**在工程中的作用**

使用static关键字定义静态变量或者静态函数，可以限制其作用域只在当前源文件内部，这样就可以避免在其他源文件中重复定义同名变量或函数，从而保证程序的模块化和可移植性。



## 2. 静态变量初始化

**只初始化一次**

静态变量是存储在全局数据区中的变量，程序运行时会在该区域分配一块固定的内存空间，因此静态变量只需要在程序运行期间初始化一次即可。

**初始化时机**

静态变量的初始化是在程序执行之前进行的，即在程序加载到内存时就已经完成了初始化，如果没有赋初值，静态变量会默认初始化为0。



## 3. 静态局部变量和全局变量

1）修饰局部变量：当用于修饰局部变量时，它会改变局部变量的生命周期和存储位置。

• 生命周期：通常情况下，局部变量的生命周期在函数调用期间。当函数返回时，局部变量会被销毁。但是，当局部变量被声明为时，它的生命周期会延长至整个程序运行期间。这意味着在多次调用函数时，局部变量会保留上次调用时的值。

• 存储位置：通常情况下，局部变量存储在栈上。但是，当局部变量被声明为时，它会被存储在静态存储区（或数据段），而不是栈上。

2）修饰全局变量：当用于修饰全局变量时，它会影响变量的可见性和链接。

• 可见性：全局变量的作用域仅限于定义该变量的源文件。这意味着其他源文件无法直接访问此变量。这有助于将变量的作用域限制在本地，避免命名冲突和不小心修改全局变量的问题。

• 链接：全局变量具有内部链接属性。这意味着在链接过程中，该变量不会与其他源文件中的同名变量发生冲突。



>静态变量和命名空间的对比：
>
>- **静态变量**：通过文件或函数作用域隔离，适合隐藏实现细节。
>- **命名空间**：通过逻辑分组隔离，适合公开接口的模块化设计。



# 二、extern

## 1. extern作用

extern是一个关键字，用于声明一个变量或函数是在其他源文件中定义的，在本文件中不会被分配内存空间，而是在链接时与其他源文件一起链接生成可执行文件。



## 2. extern "C"的作用

extern "C"用于声明一段C语言的代码，可以在C++代码中调用这段代码。C++代码和C语言代码的函数调用方式不同，C++使用函数的符号名称包含参数类型信息，而C语言使用函数的符号名称不包含参数类型信息。使用extern "C"可以将C++代码中函数的符号名称修改为C语言的符号名称，使得C++代码可以调用C语言的函数。



# 三、const

## 1. const作用

const是一个关键字，用于声明一个变量为常量，即其值在程序运行期间不可修改。const变量在定义时必须进行初始化，否则编译器会报错。



## 2. 使用情况

当程序中的某个变量的值在程序运行期间不应该被修改时，可以使用const关键字将其声明为常量，从而增加程序的可读性和可维护性。



## 3. 与 #define 的区别

• const定义的常量是有数据类型的，而define定义的常量只是简单的文本替换，没有数据类型。

• const常量具有作用域，只在定义它的作用域内有效，而define常量没有作用域，可以在文件的任何地方使用。

• const常量在编译时进行类型检查，可以发现一些隐含的错误，而define常量只是简单的文本替换，不会进行类型检查。



## 4. volatile const

表示变量只读但可能被外部修改。

（1）嵌入式硬件寄存器

硬件寄存器的值可能由外设更新，但程序不应修改它:

```c
volatile const uint32_t* STATUS_REG = (uint32_t*)0x40000000;
```

（2）**多线程/中断共享标志**

中断服务程序修改标志位，主程序仅读取：

```c
volatile const bool isr_triggered = false; // 中断中修改，主程序只读
```

**（3）ROM 或配置数据**

配置数据存储在只读内存，但可能被外部设备更新：

```c
volatile const char* CONFIG_DATA = (char*)0x8000;
```



##  5. 顶层const和底层const

顶层const表示指针本身是常量，不能修改指针指向的内容，而底层const表示指针指向的内容是常量，不能修改指针指向的内容。例如：

```c
const int* p1; // p1是一个指向常量整型数的指针，即底层const。

int* const p2; // p2是一个常量指针，即顶层const。

const int* const p3; // p3既是一个常量指针，也是一个指向常量整型数的指针，即顶层const和底层const。
```



# 四、volatile

## 1. volatile作用

关键字是C和C++编程语言中的一个修饰符，用于表示一个变量可能会被多个线程或外部事件（如硬件中断）以不可预测的方式访问和修改。关键字的作用是提醒编译器不要对该变量进行任何优化，确保每次访问该变量时都从内存中读取，每次修改该变量时都将数据写回内存。

**关键字的主要作用如下：**

• 防止编译器优化：变量会告诉编译器不要对该变量进行优化，例如避免编译器将变量值存储在寄存器中而不是内存中，或者避免编译器对多次访问变量的代码进行优化。

• 确保内存访问顺序：变量可以确保在多线程或中断环境下，变量的访问顺序与代码中的顺序一致，从而避免潜在的访问冲突。

• 用于内存映射硬件寄存器：在嵌入式系统开发中，关键字常用于表示内存映射的硬件寄存器。由于硬件寄存器的值可能在任何时候发生变化（例如，由硬件事件触发），使用关键字可以确保编译器生成正确的访问代码。





## 2. volatile和extern 作用阶段

• volatile关键字：在编译期间起作用，告诉编译器该变量可能会被意外修改，需要避免优化掉对该变量的读取或写入操作。

• extern关键字：在链接期间起作用，用于声明变量或函数是在其他源文件中定义的，本文件中不会被分配内存空间，而是在链接时与其他源文件一起链接生成可执行文件。





# 五、auto

auto是一个关键字，用于指定局部变量的存储类别，具体作用如下：

• auto修饰的变量是局部变量，默认的存储类别是auto，可以省略不写。

• auto变量的生命周期与作用域都在当前代码块内，函数返回时自动被释放。

• auto变量的初值没有保证，可能是一个随机值。



# 六、register

register是一个关键字，用于指定局部变量的存储类别，具体作用如下：

• register修饰的变量是局部变量，默认的存储类别是auto，可以省略不写。

• register变量通常被存储在CPU的寄存器中，以提高变量的访问速度。

• register变量的地址不能被取得，因此不能对其进行取地址操作。

• register变量的数量和大小都是有限制的，取决于CPU的寄存器数量和大小。



# 七、typedef

• typedef是C语言中用来定义新类型的关键字，它可以给已有的类型起一个新的别名。使用typedef定义的新类型具有与原类型相同的特性和属性。例如，typedef int INT;定义了一个新类型INT，其实就是int类型的别名。

• #define是C语言中用来定义常量或宏的预处理指令，它将在编译时被预处理器替换为指定的值。#define并不是定义新类型，而是给一个常量或表达式起一个符号名称。例如，#define PI 3.1415926定义了一个常量PI，其值为3.1415926。



# 八、stuct 与 union

• struct用于定义一组不同类型的成员变量，这些成员变量在内存中按照定义的顺序依次存放，共享内存空间。每个成员变量可以独立地访问和修改。

• union用于定义一组==相同内存空间==的成员变量，这些成员变量在内存中共享同一块空间。不同成员变量的存放位置相同，修改一个成员变量的值会影响其他成员变量的值。



# 九、inline

inline是C++语言中的一个关键字，用于修饰函数，在编译器编译时将函数调用处直接展开为函数体，从而避免了函数调用的开销，提高程序的运行速度。具体作用如下：

• inline修饰的函数在编译时将被直接展开为函数调用处的代码，从而避免了函数调用的开销，提高程序的运行速度。

• inline函数一般都定义在头文件中，可以被多个源文件调用，不会引起重复定义的错误。

• inline函数不能使用递归调用，也不能包含复杂的循环结构或switch语句等。