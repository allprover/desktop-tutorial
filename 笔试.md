---
单选题和简答题
---



1.在P2P体系网络中，假定服务器分发1000bit (F)文件给一个固定N个(N=10)对等方的集合，服务器接入链路的上行速率为us 200bps，每个对等方的上行速率ui都为100bps，下载速率di都为150bps。对于该P2P体系网络最小的分发时间近似为__。

> 8.3 秒
>
> 分发时间的限制因素
>
> - 服务器的上传能力
> - 对等方的总上传能力
> - 对等方的下载能力
> - 网络的最小割
>
> **服务器的上传时间**
>
> F/us = 1000/200 = 5s
>
> **最慢的对等方下载时间**
>
> F/di = 1000/150 = 6.666s
>
> **网络的总上传能力**
>
> N*F / us+ sum(ui) = 10×1000/(200+1000) = 8.3s



2.在Linux操作系统中，与文件命名规则有关描述中正确的是()。

A大小写对文件命名来说没有影响

B空格不能用来作为文件名

C ".."代表当前目录

D"/"代表根目录的上级目录

> A：Linux区分大小写
>
> B：空格可以在文件中，但需要引号或反斜杆
>
> C：单点代表当前目录，双点代表上级目录
>
> D：/ 是根目录，没有上级目录



3.进程在运行状态因为等待输入而会切换到____状态，调度程序在A进程运行状态时选择B进程运行，A进程会切换到____状态()

A阻塞阻塞

==B阻塞 就绪==

C就绪就绪

D就绪阻塞



4.某歌唱比赛上共有10台音箱，为了保证音乐效果，系统会有X个播放音乐的进程竞争使用，如果每个播放音乐的进程最多需要3台音箱,那么整个系统可能发现死锁的X最小值为()

A 4

B 5

C 6

D 7

> 死锁的最小X值
> 为了发生死锁，每个进程都必须持有一些音箱，同时等待更多的音箱，从而形成循环等待。具体来说：
>
> 1. 每个进程最多需要3台音箱，因此为了阻塞其他进程，每个进程可以持有2台音箱，并等待第3台。
>    - 如果每个进程持有3台音箱，那么它们已经满足了最大需求，不会等待，因此不会死锁。
>    - 如果每个进程持有1台音箱并等待另外2台，那么可能无法形成足够的竞争。
> 2. 如果每个进程持有2台音箱，那么：
>    - 每个进程还需要1台音箱才能完成（因为最多需要3台）。
>    - 但所有的音箱已经被分配，没有可用的音箱，因此所有进程都在等待，形成死锁。
> 3. 计算最小的X：
>    - 每个进程持有2台音箱，因此总共分配的音箱数为2X。
>    - 系统共有10台音箱，因此2X ≤ 10 ⇒ X ≤ 5。
>    - 当X=5时：
>      - 每个进程持有2台音箱，总共分配了10台音箱（2 * 5=10）。
>      - 所有音箱都被占用，每个进程都在等待第3台音箱，但已经没有可用的音箱。
>      - 因此，所有进程都在等待，形成死锁。
> 4. 验证X=4是否会发生死锁：
>    - 如果X=4：
>      - 每个进程持有2台音箱，总共分配了8台音箱（2 * 4=8）。
>      - 剩余的音箱数为10-8=2台。
>      - 如果有进程需要第3台音箱，可以从剩余的2台中获取，因此不会所有进程都被阻塞。
>      - 因此，X=4时不会发生死锁。



5.以下目录中,用于保存内核运行状态的是

etc

proc

dev

sys

> - /proc（Process Information Pseudofilesystem）是一个虚拟文件系统，它动态反映内核和进程的运行状态
>   - CPU、内存、磁盘等硬件信息（如 /proc/cpuinfo, /proc/meminfo）。
>   - 运行中的进程信息（如 /proc/[PID]/）。
>   - 内核参数（如 /proc/sys/）。
>   - 系统运行状态（如 /proc/uptime, /proc/loadavg）。
> - /etc 
>   - 存放系统配置文件（如 /etc/passwd, /etc/fstab）。
>   - 主要用于用户和应用程序的配置，而非内核运行状态。
> - /dev
>   - 存放设备文件（如 /dev/sda, /dev/tty），用于访问硬件设备。
>   - 属于设备管理，不直接反映内核运行状态。
> - /sys
>   - /sys（sysfs）提供内核对象（如设备、驱动、模块）的接口。
>   - 与 /proc 类似，但更侧重于硬件设备和驱动的管理，而非运行状态监控。
>   - /proc 更专注于“运行状态”，而 /sys 更专注于“设备与驱动”。



6.以下属于字符设备的有

终端设备驱动

网络设备驱动

磁盘

SD设备驱动

> 1. 终端设备驱动
>    - 终端（如 /dev/tty, /dev/pts/*）是典型的字符设备。
>    - 特点：
>      - 数据以**字符流（按字节）**形式传输（如键盘输入、串口通信）。
>      - 不支持随机访问（必须按顺序读写）。
> 2. SD设备驱动
>    - 大多数情况下，SD卡作为块设备（如 /dev/mmcblk0）用于文件系统存储。
> 3. 网络设备驱动
>    - 单独的一类
> 4. 硬盘
>    - 磁盘（如硬盘、SSD）是典型的块设备（如 /dev/sda）。



7.以下关于线程中的PID和TID的描述正确的为

线程PID和线程TID意义相同

线程TID在系统内是唯一的

线程PID在系统内不是唯一的

其余一项都不对

> - PID（进程ID）
>   - 每个进程有一个唯一的PID。
>   - 同一个进程的所有线程共享相同的PID（因为它们属于同一个进程）。
> - TID（线程ID）
>   - 每个线程有一个唯一的TID（包括主线程和子线程）。
>   - TID在整个系统内是唯一的（内核用TID调度线程）。
>   - 主线程的TID = 进程的PID，但子线程的TID是独立分配的。



8.在64位系统中如下结构中s.x、s.y 和next的相对偏移量各自多少?

```c
struct foo{
    int*p;
    struct {
        long y;
        int x;
    } s;
    struct foo *next;
}
```

12，8，16

12，4，16

16，8，20

8，4，12

> 64位系统的基本数据结构大小
>
> - 指针：8字节
> - long：8字节
> - int：4字节
> - long long：8字节
> - short：2字节
> - float：4字节
> - double：8字节
> - long double：16字节
> - char：1字节



9.在32位系统中有如下结构体:

```c
typedef struct
{
    int a;

    float b;

    char c[253];

    double d;

    char f[35];

    long int e;

    short g;

    short *ptr1;

    int*ptr2;

    short h[33];

    char *prt3;
}HIKVISION;
```

sizeof (HIKVISION)等于多少?现要进行内存占用优化，从结构体入手，你觉得成员之间可以怎么调整?

> 32位系统的基本数据结构大小
>
> - 指针：4字节
> - long int：4字节
> - int ：4字节
> - float：4字节
> - char：1字节
> - double：8字节
> - short：2字节
>
> 优化后的结构体：
>
> ```c
> typedef struct {
>     double d;          // 8字节（偏移量0）
>     int *ptr2;         // 4字节（偏移量8）
>     char *ptr3;        // 4字节（偏移量12）
>     short *ptr1;       // 4字节（偏移量16）
>     int a;             // 4字节（偏移量20）
>     float b;           // 4字节（偏移量24）
>     long int e;        // 4字节（偏移量28）
>     char c[253];       // 253字节（偏移量32）
>     char f[35];        // 35字节（偏移量285）
>     short h[33];       // 66字节（偏移量320）
>     short g;           // 2字节（偏移量386）
> } HIKVISION;
> ```



10.指出其中的错误

TEMP_CFG *p_temp_info =NULL;

p_temp_info = malloc(sizeof(TEMP_CFG));

memset(&p_temp info, 0,sizeof(p_temp_info));

>1. memset 使用错误
>
>`memset(&p_temp_info, 0, sizeof(p_temp_info));`
>
>- p_temp_info 是一个指针变量，&p_temp_info 获取的是指针变量本身的地址，而不是它指向的内存地址。
>- sizeof(p_temp_info) 返回的是指针变量的大小（在64位系统通常是8字节），而不是 TEMP_CFG 结构体的大小。
>- 导致
>  - 只清零了指针变量 p_temp_info 本身（8字节），而不是它指向的 TEMP_CFG 结构体。
>  - 如果 TEMP_CFG 结构体比8字节大，剩余部分不会被初始化，可能导致未定义行为。
>- memset 正确使用
>  - `memset(p_temp_info, 0, sizeof(TEMP_CFG));`
>
>2. 未检查 malloc 返回值
>
>- malloc 可能返回 NULL（内存不足时），直接使用 memset 会导致段错误（Segmentation Fault）。
>
>- ```c
>  if (p_temp_info == NULL) {
>      perror("malloc failed");
>      exit(EXIT_FAILURE);
>   }
>  ```
>
>3. 申请的内存大小不对



11.Linux系统中，对普通文件的操作，关于对fopen和open的区别描述正确的是

==open是系统函数，不可移植；fopen是标注c函数，可移植==

==fopen是带缓存的的文件系统,文件系统中内存中开辟一定的缓冲区,读写操作先操作缓冲区;open是非缓冲文件系统:依赖操作==

==open属于低级IO, fopen属于高级IO==

一般情况下,顺序访问和随机访问文件,fopen都比open快

> 顺序访问：fopen 通常更快（缓冲区减少系统调用次数）。
>
> 随机访问：open 可能更快（fopen 的缓冲区可能导致额外拷贝，如 fseek 需刷新缓冲区）。



12.HTTP以下请求方法哪些一般含主体(即body)?

HEAD

GET

PUT

POST

> ✅ 一般包含Body的请求方法
> 1. POST
> 用途：向服务器提交数据（如表单提交、文件上传、API请求）。
> 是否含Body：是
> 例如：POST /users 可能携带JSON数据 {"name": "Alice"}。
> 2. PUT
> 用途：向服务器上传或替换资源（如更新文件内容）。
> 是否含Body：是
> 例如：PUT /files/1.txt 可能携带文件内容作为Body。
>
> ❌ 一般不包含Body的请求方法
> 1. GET
> 用途：请求获取资源（如加载网页、查询数据）。
> 是否含Body：否
> HTTP标准规定GET请求的语义是“获取资源”，不应包含Body（但技术上可以，实际中极少使用）。
> 2. HEAD
> 用途：仅获取响应头（如检查资源是否存在或修改时间）。
> 是否含Body：否
> 服务器必须忽略HEAD请求的Body（即使客户端发送了Body）。

13.以下是实时调度策略是

SCHED_RT

SCHED_RR

SCHED_FIFO

SCHED_OTHER

> 1. SCHED_FIFO（先进先出）
>
> 2. SCHED_RR（轮转调度）
>
> 3. SCHED_RT（广义实时策略）:不是Linux标准
> 4. SCHED_OTHER（默认策略，即CFS）：非实时策略

14.在同一函数内,内存释放后立即访问,以下描述正确的是

A它的内容是完整的,因此可以继续被访问

B内存的位置是有效的

C只读不写就不会有什么问题

==D都不对，释放的内存绝对不能再访问==

>free 后的内存访问是未定义行为，可能的表现包括：
>
>- 程序崩溃（如触发段错误）。
>- 数据错误（读取到垃圾值或被其他程序修改的数据）。
>- 安全漏洞（如释放后重用漏洞，Use-After-Free）。



15、下面哪种变量定义不当,可能导致堆栈溢出?

A静态全局变量

B动态全局变量

C静态局部变量

D动态局部变量

>动态局部变量，栈区，函数递归调用过深，或者局部变量占用过多栈空间，会导致栈溢出

 

16.下列选项正确的有?

A

const int val=41;

const int *ptr= &val;

ptr++;

B

const int val =41;

int *const ptr = &val;

ptr++;

C

int val = 41;

int *const ptr = &val;

*ptr +=82;

D

int val=41;

int const *ptr = &val;

ptr++;

>A：Val 是常量，ptr 是一个指向常量的指针（可以修改指针，但不能修改 *ptr)，ptr++只会对地址递增
>
>B：val 是常量，ptr 是一个常量指针（不能修改指针，但可以修改 *ptr）ptr++会修改指针
>
>C：val 非常量，ptr 是一个常量指针。*ptr+=82会修改val的值
>
>D：val 非常量，ptr 是一个指向常量的指针，ptr++以及*ptr都是可以的



17.下列关于C语言中static关键字的描述,正确的是:

A static只能用来修饰变量，不能用来修饰函数

B全局变量前加static表示该变量的作用域限制变量所在的文件中

C static修饰的局部变量的作用域限制在变量所在的函数中

D static修饰的局部变量分配在内存的全局数据区

>static 修饰的局部变量 作用域仍然仅限于函数内（和普通局部变量一样）。
>但它的 生命周期延长至整个程序运行期间（存储在全局数据区，而非栈上）。



18.执行下面的一端C程序后,变量sum的值应为

```c
char chr =127;
int sum =300;
chr +=1;
sum +=chr;
```

300

428

427

172

>char 是8为有符号正式，取值-128~127
>
>那么 chr +=1 ，128的二进制：1000 0000，最高位的1为符号位，也就是 -128



19.当想要查看某个连接的tcp状态及收发队列情况，可以执行下面哪个命令()

netstat

ethtool

iperf

tcpdump

> - netstat - 这个工具能显示网络连接、路由表、接口统计等网络相关信息。特别是使用 -a 和 -n 选项显示所有连接和非解析地址，或 -t 只显示TCP连接，可以查看每个TCP连接的状态，如 ESTABLISHED, SYN_SENT 等，以及使用 -o 选项查看计时信息。
>
> - ethtool - 这个命令主要用于查询和控制网络驱动程序和硬件设置，比如获取网卡的速度、双工模式、硬件中断等信息，不适用于查看TCP连接状态。
>
> - iperf - 主要用于网络性能测试，可以测试网络带宽、延迟、丢包率等，不提供TCP连接的详细状态信息。
>
> - tcpdump - 主要用于捕获网络上传输的数据包并输出详细信息，适用于网络问题调试，但它并不直接显示TCP连接的状态，而是展示网络数据包的实时流。



20.如下代码运行后输出内容是()

int a= 5;

void prt_func(char array[64], int a)

{

char str[]= "hello world";

char*p = str;

char vs[a];a++;

printf("size is %d %d %d %d\n", sizeof(array), strlen(str), sizeof(p), sizeof(vs));

return;

}

64,11,4,6

64,12,11,5

4,11,4,5

64,12,4,6

> sizeof(array) 为4（32位系统中的指针大小）。
>
> strlen(str) 为11（"hello world" 的长度）。
>
> sizeof(p) 为4（32位系统中的指针大小）。
>
> sizeof(vs) 为5（变长数组，初始化时 a 的值为5）。



21.设数组int a[4]={1,3,4,5}那么如下运算的最终结果是?

(*a)++ *3 + 1 << 2 + 1)

56

41

32

29

> *a = 1
>
> *a先和3乘，1×3=3，然后再加+1=4
>
> <<优先级小于+，那么4<<3
>
> 这里的自增不用管，(*a)++ 先返回 1，然后 a[0] 自增为 2。



22.以下对于NAND FLASH和NOR FLASH的描述正确的是（）

==NAND的擦除单元H比NOR小==

NOR的擦除速度远比NANDR快

NOR的写入速度比NAND快很多

==NAND最大擦写次数是一百万次NOR是十万次==



23.以下哪些符号可以实现将两个宏定义连接在一起?

&&

==**\##**==

\#@

\#



24.现在需要将脚本test.sh的标准输出和标准错误输出重定向至文件test.log，下列命令中正确的是

bash test.sh &>test.log

.bash test.sh>&test.log

bash test.sh > test.log 2>&1

bash test.sh 2>test.log 1>hello.log

>&>是同时重定向标准输出（stdout）和标准错误（stderr）到文件的简写语法，符合要求
>
>》test.log：将标准输出重定向到 test.log；
>
>2>&1：将标准错误（文件描述符2）重定向到标准输出（文件描述符1）的同一位置，即最终合并到 test.log 中567。





